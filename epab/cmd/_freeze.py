# coding=utf-8
"""
Freeze package into exe
"""
import datetime
import platform
from distutils.sysconfig import get_python_lib as site_package  # pylint: disable=import-error
from pathlib import Path

import certifi
import click
import elib_run
import jinja2

import epab.cmd
import epab.exc
import epab.utils
from epab import __version__
from epab._logging import LOGGER
from epab.core import CTX, config

VERPATCH_PATH = epab.utils.resource_path('epab', './vendor/verpatch.exe')
ICO = epab.utils.resource_path('epab', './vendor/app.ico')
BASE_CMD = [
    'pyinstaller',
    '--log-level=WARN',
    '--noconfirm',
    '--clean',
    '--icon', f'"{ICO}"',
    '--workpath', './build',
    '--distpath', './dist',
    '--add-data', f'"{certifi.where()};."',
    '--name'
]

_FROZEN_VERSION_TEMPLATE = '''# coding=utf-8
"""
This file has been automatically generated by EPAB.

Do not edit this file manually, as all changes will be lost.
"""

__version__ = "{{version}}"
__info__ = {{ "{" }}
    'epab': {{ "{" }}
        'version': "{{epab_version}}",
    {{ "}" }},
    'pyinstaller': {{ "{" }}
        'version': "{{pyinstaller_version}}",
    {{ "}" }},
    'python': {{ "{" }}
        'build': {{platform.python_build()}},
        'version': "{{platform.python_version()}}",
        'implementation': '{{platform.python_implementation()}}',
        'compiler': '{{platform.python_compiler()}}',
    {{ "}" }},
    'platform': {{ "{" }}
        'name': '{{platform.platform()}}',
        'architecture': {{platform.architecture()}},
        'uname': {{ "{" }}
            'system': "{{uname.system}}",
            'node': "{{uname.node}}",
            'release': "{{uname.release}}",
            'version': "{{uname.version}}",
            'machine': "{{uname.machine}}",
            'processor': "{{uname.processor}}",            
        {{ "}" }},        
    {{ "}" }},
    'packages': {{ "{" }}{% for package in packages %}
        '{{package[0]}}': '{{package[1]}}',{% endfor %}
    {{ "}" }},
{{ "}" }}

'''


def _collect_installed_packages() -> list:
    raw_content, code = elib_run.run('pip freeze')
    if code != 0:
        raise RuntimeError('failed to obtain "pip freeze" results')
    return [line.split('==') for line in raw_content.split('\n')]


def write_frozen_version_file(build_version: str):
    """
    Writes a `_frozen.py` file inside the package directory.

    That file contains information about the build environment, and the version of the the application. This allows
    quicker retrieval of version (and other info) at runtime, bypassing having the dissect & read the exe itself.

    :param build_version: version of the package that is being built
    """
    LOGGER.debug('collecting information about the host machine')
    LOGGER.debug('collecting installed packages')
    packages = _collect_installed_packages()
    print(packages)
    template = jinja2.Template(_FROZEN_VERSION_TEMPLATE)
    file_content = template.render(
        epab_version=__version__,
        version=build_version,
        pyinstaller_version=_get_pyinstaller_version(),
        uname=platform.uname(),
        platform=platform,
        packages=packages,

    )
    _frozen_py_path = Path(config.PACKAGE_NAME() + '/__frozen__.py').absolute()
    LOGGER.debug('writing frozen info file to: %s', str(_frozen_py_path))
    _frozen_py_path.write_text(file_content)


def _get_site_package_directory() -> str:
    return site_package()


_DATA_FILE_REPLACE = {
    '{site_package}': _get_site_package_directory(),
}


def _format_data_file(data_file: str) -> str:
    for _replacement_src, _replacement_tgt in _DATA_FILE_REPLACE.items():
        data_file = data_file.replace(_replacement_src, _replacement_tgt)
    LOGGER.debug('formatted data file str: %s', data_file)
    return data_file


def _get_pyinstaller_version() -> str:
    version, code = elib_run.run('pyinstaller --version')

    # Assuming the executable was found, check the error code
    # (if the exe wasn't found, `elib_run.ExecutableNotFoundError` will be raised)
    if code != 0:
        raise RuntimeError('failed to obtain pyinstaller version')

    return version


@epab.utils.timeit
def _install_pyinstaller():
    LOGGER.info('checking PyInstaller installation')
    try:
        _get_pyinstaller_version()
    except elib_run.ExecutableNotFoundError:
        LOGGER.info('installing PyInstaller')
        elib_run.run('pip install pyinstaller==3.4')
        _get_pyinstaller_version()


@epab.utils.timeit
def _patch(version: str):
    now = datetime.datetime.utcnow()
    timestamp = f'{now.year}{now.month}{now.day}{now.hour}{now.minute}'
    year = now.year
    cmd = [
        str(epab.utils.resource_path('epab', './vendor/verpatch.exe')),
        f'./dist/{config.PACKAGE_NAME()}.exe',
        '/high',
        version,
        '/va',
        '/pv', version,
        '/s', 'desc', config.PACKAGE_NAME(),
        '/s', 'product', config.PACKAGE_NAME(),
        '/s', 'title', config.PACKAGE_NAME(),
        '/s', 'copyright', f'{year}-etcher',
        '/s', 'company', 'etcher',
        '/s', 'SpecialBuild', version,
        '/s', 'PrivateBuild', f'{version}-'
                              f'{CTX.repo.get_current_branch()}_'
                              f'{CTX.repo.get_sha()}-{timestamp}',
        '/langid', '1033',
    ]
    elib_run.run(' '.join(cmd))
    LOGGER.info('patch OK')


@epab.utils.timeit
def _freeze(version: str):
    if not config.FREEZE_ENTRY_POINT():
        LOGGER.error('no entry point defined, skipping freeze')
        return
    _install_pyinstaller()
    write_frozen_version_file(version)
    cmd = BASE_CMD + [config.PACKAGE_NAME(), '--noupx --onefile', config.FREEZE_ENTRY_POINT()]
    for data_file in config.FREEZE_DATA_FILES():
        LOGGER.debug('appending data file: %s', data_file)
        data_file = _format_data_file(data_file)
        cmd.append(f'--add-data "{data_file}"')
    LOGGER.info('freezing %s', config.PACKAGE_NAME)
    elib_run.run(' '.join(cmd), timeout=300)
    elib_run.run('pipenv clean', failure_ok=True)
    LOGGER.info('freeze OK')
    _patch(version)


@epab.utils.timeit
def _clean_spec():
    spec_file = Path(f'{config.PACKAGE_NAME()}.spec')
    spec_file.unlink()


@click.command()
@click.pass_context
@click.argument('version')
@click.option('-c', '--clean', is_flag=True, default=False, help='Clean spec file before freezing')
@click.option('-v', '--version', default=None, help='Specify the version number for freezing')
def freeze(ctx, version: str, clean: bool):
    """
    Freeze current package into a single file
    """
    if clean:
        _clean_spec()
    ctx.invoke(epab.cmd.compile_qt_resources)
    _freeze(version)
